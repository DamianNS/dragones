@page "/"
@using Editor.Components.Componentes
@using Editor.Models
@using Editor.Models.Enums
@inject IJSRuntime JS

<PageTitle>Editor de mapas Dragones</PageTitle>

<style>
    :root {
        --tile-size: @(TileSize)px;
        --map-cols: @MapWidth;
    }

    .botonFclecha {
        width: 48px;
        height: 48px;
        display: flex;
        align-items: center;
        justify-content: center;
        font-size: 1.5rem;
        padding: 0;
    }
</style>

<h1>Editor de Mapas Dragones</h1>

<div class="d-flex flex-row">
    <div class="m-1 d-flex flex-column gap-1">        
        <InputSelect @class="form-select" TValue="Mapa" @bind-Value="selectedMapa" class="form-select" @onchange="onChangeTypeTile">
            @foreach (var mapa in Mapas)
            {
                <option value="@mapa">@mapa.Nombre</option>
            }
        </InputSelect>
        <button class="btn btn-primary" @onclick="onCargarMapa">Cargar Mapa</button>
        <button class="btn btn-primary" @onclick="nuevoMapa">Nuevo Mapa</button>
        <button class="btn btn-primary" @onclick="SaveMapa">Guardar Mapa</button>
    </div>
    <div class="m-1 flex-grow-1">
        <div style="max-width: 800px; max-height: 700px;overflow: auto; ">
            <div id="mapGrid" class="map-grid" style="display: grid; grid-template-columns: repeat(var(--map-cols), var(--tile-size)); width: fit-content; height: fit-content;">
                @for (int y = 0; y < 50; y++)
                {
                    for (int x = 0; x < 50; x++)
                    {
                        var tile = selectedMapa?.Tiles[x, y];
                        var tipo = tile != null ? tile.Type : TileTypeEnum.Empty;
                        <TileComponent X="x" Y="y" Size="TileSize" Type="tipo" Tile="tile"></TileComponent>
                    }
                }
            </div>        
        </div>
    </div>
    <div class="m-1 d-flex flex-column">
        <label>Tamaño de Tile: @TileSize px</label>
        <label>Cursor: (X:@CursorX)-(Y:@CursorY)</label>
        @foreach(var tile in Tiles)
        {            
            <div class="p-1 m-1 border border-1 d-flex flex-row align-items-center gap-1">
                <InputCheckbox class="me-1" Value="tile.Value.IsChecked"
                                ValueChanged="@((bool v) => HandleCheckboxChange(v, tile.Key))"
                                ValueExpression="@(() => tile.Value.IsChecked)"></InputCheckbox>
                <label class="me-1">@tile.Value.Type.ToString()</label>                
                <TileComponent X="0" Y="0" Size="15" Type="tile.Value.Type" Tile="tile.Value"></TileComponent>
            </div>
        }
        <div class="p-1 d-flex flex-row m-1 border border-info gap-1">
            @if(Tiles.Any()){
                <InputSelect @class="form-select" TValue="TileTypeEnum" @bind-Value="tipoo" class="form-select" @onchange="onChangeTypeTile">
                    @foreach (var type in Enum.GetValues<TileTypeEnum>())
                    {
                        <option value="@type">@type.ToString()</option>
                    }
                </InputSelect>
                <button class="btn btn-primary" @onclick="() => onActualizarTile(tipoo)">Actualizar</button>
            }            
            <button @onclick="onAgregarTile">Agregar</button>
        </div>
        <div class="d-flex flex-column border border-info align-items-center p-2">
            <div class="d-grid" style="grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap:8px; justify-items:center; align-items:center;">
                <!-- Row 1 -->
                <div></div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onPared(DirectionEnum.Top)" aria-label="Arriba" title="Arriba">↑</button>
                <div></div>

                <!-- Row 2 -->
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onPared(DirectionEnum.Left)" aria-label="Izquierda" title="Izquierda">←</button>
                <div style="width:48px; height:48px; display:flex; align-items:center; justify-content:center;">
                    <!-- centro vacío opcional -->
                    <span class="text-muted" style="font-size:0.8rem">Paredes</span>
                </div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onPared(DirectionEnum.Right)" aria-label="Derecha" title="Derecha">→</button>

                <!-- Row 3 -->
                <div></div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onPared(DirectionEnum.Bottom)" aria-label="Abajo" title="Abajo">↓</button>
                <div></div>
            </div>
        </div>
        <div class="d-flex flex-column border border-info align-items-center p-2">
            <div class="d-grid" style="grid-template-columns: repeat(3, 48px); grid-template-rows: repeat(3, 48px); gap:8px; justify-items:center; align-items:center;">
                <!-- Row 1 -->
                <div></div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onAbertura(DirectionEnum.Top)" aria-label="Arriba" title="Arriba">↑</button>
                <div></div>

                <!-- Row 2 -->
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onAbertura(DirectionEnum.Left)" aria-label="Izquierda" title="Izquierda">←</button>
                <div style="width:48px; height:48px; display:flex; align-items:center; justify-content:center;">
                    <!-- centro vacío opcional -->
                    <span class="text-muted" style="font-size:0.8rem">Averturas</span>
                </div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onAbertura(DirectionEnum.Right)" aria-label="Derecha" title="Derecha">→</button>

                <!-- Row 3 -->
                <div></div>
                <button class="btn btn-outline-primary botonFclecha" @onclick="() => onAbertura(DirectionEnum.Bottom)" aria-label="Abajo" title="Abajo">↓</button>
                <div></div>
            </div>
        </div>
    </div>
</div>

<div>
    <label>Sum +</label>
    <label>Sum -</label>
</div>

<script>
    window.setupTileNavigation = (rows, cols, dotNetHelper) => {

        let lastActiveBeforePointer = null;
        const recordActiveBefore = (ev) => {
            try {
                lastActiveBeforePointer = document.activeElement;
            } catch (err) {
                lastActiveBeforePointer = null;
            }
        };

        document.addEventListener('pointerdown', recordActiveBefore, true);
        document.addEventListener('mousedown', recordActiveBefore, true);
        document.addEventListener('touchstart', recordActiveBefore, true);

        const mapEl = document.getElementById('mapGrid');
        if (mapEl) {
            console.log('mapEl');
            mapEl.addEventListener('click', (ev) => {
                console.log('click');
                const prevActive = lastActiveBeforePointer;

                const rect = mapEl.getBoundingClientRect();
                // Leer tamaño del tile desde la variable CSS --tile-size
                const cssTile = getComputedStyle(document.documentElement).getPropertyValue('--tile-size');
                const tileSize = parseInt(cssTile) || 16;

                const x = Math.floor((ev.clientX - rect.left) / tileSize);
                const y = Math.floor((ev.clientY - rect.top) / tileSize);

                if (x >= 0 && x < cols && y >= 0 && y < rows) {
                    // Invoca método C# en la instancia pasada como dotNetHelper
                    // dotNetHelper.invokeMethodAsync('MapClicked', x, y);

                    const active = document.activeElement;
                    const nextTile = document.getElementById(`tile-${x}-${y}`);                    
                    if (nextTile) {
                        if (prevActive && prevActive.style) prevActive.style.zIndex = 1;
                        nextTile.focus();
                        nextTile.style.zIndex = 10;
                        dotNetHelper.invokeMethodAsync('ActualizaCursor', x, y);
                    }
                }
                lastActiveBeforePointer = null;
            });
        }

        document.addEventListener('keydown', (e) => {
            if(e.key == "+") {
                var tiles = document.getElementsByTagName("TileComponent");
                 dotNetHelper.invokeMethodAsync('ExecuteZoom', 1);
                e.preventDefault();
                return;
            }

            if(e.key == "-") {
                var tiles = document.getElementsByTagName("TileComponent");
                 dotNetHelper.invokeMethodAsync('ExecuteZoom', -1);
                e.preventDefault();
                return;
            }

            const active = document.activeElement;
            if (!active || !active.id.startsWith('tile-')) return;

            // Extraer X e Y del ID actual "tile-x-y"
            const parts = active.id.split('-');
            let x = parseInt(parts[1]);
            let y = parseInt(parts[2]);

            switch (e.key) {
                case "ArrowUp":    y = Math.max(0, y - 1); break;
                case "ArrowDown":  y = Math.min(rows - 1, y + 1); break;
                case "ArrowLeft":  x = Math.max(0, x - 1); break;
                case "ArrowRight": x = Math.min(cols - 1, x + 1); break;
                case " ":
                    dotNetHelper.invokeMethodAsync('ActualizaTile', x,y);
                    e.preventDefault();
                    return;
                case "Backspace":
                    dotNetHelper.invokeMethodAsync('DeleteTile', x,y);
                    e.preventDefault();
                    return;
                default: 
                    console.log(e.key);
                    return; //No es una tecla de dirección
            }

            e.preventDefault(); // Evita que la página haga scroll
            const nextTile = document.getElementById(`tile-${x}-${y}`);
            if (nextTile) {
                active.style.zIndex = 1;
                nextTile.focus();
                nextTile.style.zIndex = 10;
                dotNetHelper.invokeMethodAsync('ActualizaCursor', x, y);
            }
        });
    };
</script>